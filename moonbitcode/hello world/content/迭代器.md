#### 迭代器
	用来遍历访问某个序列的元素的对象。
1）外部迭代器（对用户可见）：使用 `Iterator<T>` 和 `next()` `hasNext()` 来步进一个迭代过程
2）内部迭代器（对用户不可见）：则是通过接收某个操作和序列，并在遍历过程中将操作应用于该序列的高阶函数来实现迭代器。

MoonBit 的内置类型 `Iter[T]` 提供了迭代器支持。基本上所有的内置序列结构都实现了 Iter：
```
fn filter_even(l : Array[Int]) -> Array[Int] {
  let l_iter : Iter[Int] = l.iter()
  l_iter.filter(fn { x => (x & 1) == 1 }).collect()
}//获取一个array中的奇数项的array

fn fact(n : Int) -> Int {
  let start = 1
  start.until(n).fold(Int::op_mul, init=start)
}

```
常用的方法包括：

- `each`：遍历迭代器的每个元素，并将接收的函数应用于每个元素上
    
- `fold`：用给定的函数和一个初始值折叠（归约）某个迭代器
    
- `collect`：将迭代器中的元素收集到一个 `Array` 中
    
- `filter`：（惰性）用某个函数（谓词）过滤迭代器的元素
    
- `map`：（惰性）用某个函数转化迭代器中的元素
    
- `concat`：（惰性）将一个迭代器中的元素全部加到另一个的尾部
（惰性：即调用方法不会立即执行迭代，因为套了一层函数，Iter不产生中间值）

3）实现细节：
`Iter[T]` 接收一个函数 `(T) -> IterResult` 并利用其转换自身的状态（`IterResult`），转换后的状态是两者中的哪一个则由这个函数决定。
（包含- `IterEnd`：表示迭代终点
       - `IterContinue`：表示迭代尚未到达终点，即迭代在这个状态下会进行下去。
       两种迭代状态）