#### 函数：
	用fn来定义一个函数（同时不应该以A-Z来起头命名一个函数）
```
fn identity[T](x : T) -> T { 
  x+x
  x
}

```
##### 1）显示类型标注：
x: T，表示x的数据类型时T，而整行中的（A）->T表示，输入的参数及其类型，后方是表示返回的类型

##### 2）返回式：
不同于c++中有return，moonbit中只有最后一行可作为返回值的表达式；如实例代码中的就是返回x

##### 3）局部函数：
局部函数可以是命名或是匿名的，多数情况下局部函数的类型注解（通过引用周围词法作用域的绑定）可省略
```
fn foo() -> Int {
  fn inc(x) { x + 1 }       // 命名为 `inc`
  fn (x) { x + inc(2) } (6) // 匿名，立即应用到整数字面量 6;定义完后立即调用
}//最终等式：6+（2+1）

```

##### 4)可选参数：
带有默认值的带标签参数,默认语法
```
~label : Type = default_expr
```
实例：==~opt: Int=42==，每次使用默认参数调用一个函数时，都会重新求值默认值的表达式，这会导致每次默认表达值是重新获得，没有记忆性
```
fn optional(~opt : Int = 42) -> Int {
  opt
}
```
在多次不同的函数调用之间共享默认值：可以提前用 `let` 计算并保存默认值
```
let default_counter : Ref[Int] = { val: 0 }//进行绑定

fn incr(~counter : Ref[Int] = default_counter) -> Int {
  counter.val = counter.val + 1
  counter.val
}

fn main {
  println(incr()) // 1
  println(incr()) // 依然是 1，因为重新求值了默认表达式，产生了一个新的 Ref
  let counter : Ref[Int] = { val: 0 }
  println(incr(~counter)) // 1
  println(incr(~counter)) // 2，因为两次调用使用了同一个 Ref
}
```
##### 5）自动填充的参数：
每次函数调用时填充某些特定类型的参数，要声明这种自动填充的参数，只需要使用 `_` 作为参数的默认值即可。如果在调用时没有提供这个参数，MoonBit 就会自动根据调用处的上下文填充这个参数。(用处不算特别大)
**目前 MoonBit 支持两种类型的自动填充参数。代表整个函数调用在源码中位置的 `SourceLoc` 类型，以及包含每个参数各自的位置的 `ArgsLoc` 类型：**
```
fn f(_x : Int, _y : Int, ~loc : SourceLoc = _, ~args_loc : ArgsLoc = _) -> Unit {
  println("整个函数调用的位置：\{loc}")
  println("各个参数的位置：\{args_loc}")
}

fn main {
  f(1, 2)
  // 整个函数调用的位置：<文件名>:7:3-7:10
  // 各个参数的位置：[Some(<文件名>:7:5-7:6), Some(<文件名>:7:8-7:9), None, None]
}

```