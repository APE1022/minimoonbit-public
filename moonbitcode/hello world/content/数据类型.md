#### 数据类型
	用于创建新数据类型
工具：`struct` 和 `enum`
1）struct
在 MoonBit 中，结构与元组类似，但==它们的字段由字段名索引==。 结构体可以使用结构体字面量构造，==结构体字面量由一组带有标签的值组成==，并用花括号括起来。 如果结构体字面量的字段完全匹配类型定义，则其类型可以被自动推断。 使用点语法 `s.f` 可以访问结构体字段。 如果一个字段使用关键字 `mut` 标记为可变，那么可以给它赋予新的值（==即可以修改值==）。
```
struct User {
  id: Int
  name: String
  mut email: String
}

fn main {
  let u = { id: 0, name: "John Doe", email: "john@doe.com" }
  u.email = "john@doe.name"
  println(u.id)
  println(u.name)
  println(u.email)
}
```
更新结构体：
只需修改现有结构体的一部分字段，其他字段的值保持不变(`..user`)， 可以使用结构体更新语法：
```
struct User {
  id: Int
  name: String
  email: String
} derive(Show)

fn main {
  let user = { id: 0, name: "John Doe", email: "john@doe.com" }
  let updated_user = { ..user, email: "john@doe.name" }
  println(user)          // 输出: { id: 0, name: "John Doe", email: "john@doe.com" }
  println(updated_user)  // 输出: { id: 0, name: "John Doe", email: "john@doe.name" }
}
```

2）enum枚举
	枚举由一组分支（构造器）组成，每个分支都有一个名字（==必须以大写字母开头==），可以用这个名字来构造对应分支的值， 或者在模式匹配中使用这个名字来判断某个枚举值属于哪个分支
```
// 一个表示两个值之间的有序关系的枚举类型，有 “小于”、“大于”、“等于” 三个分支
enum Relation {
  Smaller
  Greater
  Equal
}

// 计算两个整数之间的顺序关系
fn compare_int(x: Int, y: Int) -> Relation {
  if x < y {
    // 创建枚举时，如果知道想要什么类型，可以直接写分支/构造器的名字来创建
    Smaller
  } else if x > y {
    // 但如果不知道类型，永远可以通过 `类型名字::构造器` 的语法来无歧义地创建枚举值
    Relation::Greater
  } else {
    Equal
  }
}

// 输出一个 `Relation` 类型的值
fn print_relation(r: Relation) -> Unit {
  // 使用模式匹配判断 r 属于哪个分支
  match r {
    // 模式匹配时，如果知道类型，直接使用构造器名字即可
    Smaller => println("smaller!")
    // 但也可以用 `类型名字::构造器` 的语法进行模式匹配
    Relation::Greater => println("greater!")
    Equal => println("equal!")
  }
}

fn main {
  print_relation(compare_int(0, 1)) // 输出 smaller!
  print_relation(compare_int(1, 1)) // 输出 equal!
  print_relation(compare_int(2, 1)) // 输出 greater!
}
```