#### 访问控制

1）默认情况下，==所有函数定义和变量绑定对其他包都是 _不可见_ 的==； ==没有修饰符的类型==是**抽象数据类型**，其名称被导出，但内部是不可见的。 这种设计防止了意外暴露实现细节。 您可以在 `type`/`fn`/`let` ==前使用`pub` 修饰符使其完全可见，或在 `type` 前使用 `priv` 修饰符使其对其他包完全不可见==。 您还可以在字段名前使用 `pub` 或 `priv` 获得更细粒度的访问控制。
->形成.h和.cpp的封装结构

specially：
- 在**抽象或私有结构体内**（无前缀或前缀声明为priv），所有字段都不能被定义为 `pub`，因为这样没有意义。
- 枚举类型的构造器没有单独的可见性(枚举类内内部成员无法被声明为pub或priv），所以不能在它们前面使用 `pub` 或 `priv`

2）实例
```
struct R1 {       // 默认为抽象数据类型
  x: Int          // 隐式的私有字段
  pub y: Int      // ERROR: 在抽象类型中找到了 `pub` 字段！
  priv z: Int     // WARNING: `priv` 是多余的！
}

//可以选择这个公有访问的结构内有多少是可以访问的
pub struct R2 {       // 显式的公共结构
  x: Int              // 隐式的公共字段
  pub y: Int          // WARNING: `pub` 是多余的！
  priv z: Int         // 显式的私有字段
}

priv struct R3 {       // 显式的私有结构
  x: Int               // 隐式的私有字段
  pub y: Int           // ERROR: `pub` 字段出现在了私有类型中！
  priv z: Int          // WARNING: `priv` 是多余的！
}

enum T1 {       // 默认为抽象数据类型
  A(Int)        // 隐式的私有变体
  pub B(Int)    // ERROR: 无独立可见性！
  priv C(Int)   // ERROR: 无独立可见性！
}

pub enum T2 {       // 显式的公共枚举
  A(Int)            // 隐式的公共变体
  pub B(Int)        // ERROR: 无独立可见性！
  priv C(Int)       // ERROR: 无独立可见性！
}

priv enum T3 {       // 显式的私有枚举
  A(Int)             // 隐式的私有变体
  pub B(Int)         // ERROR: 无独立可见性！
  priv C(Int)        // ERROR: 无独立可见性！
}

```

3）pub（readonly）