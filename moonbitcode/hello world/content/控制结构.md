#### 控制结构
##### 1.if-else：条件语句不用（）；需要注意==条件表达式总是返回一个值，其结果和 `else` 子句的返回值类型必须相同==
```
if x == y {
  expr1
} else {
  expr2
}

if x == y {
  expr1
}

```
##### 2.while:同样判断条件无（）
基础形态；
```
let mut i = 5
while i > 0 {
  println(i)
  i = i - 1
}
```
支持break和continue
```
fn main {
  let mut i = 5
  while i > 0 {
    i = i - 1
    if i == 4 { continue }
    if i == 1 { break }
    println(i)
  }
}
```
支持else，当存在 `else` 子句时，`while` 循环也可以返回一个值，返回值是 `else` 子句语句块的求值结果。此时如果使用`break`跳出循环，需要在`break`后提供一个返回值，类型与`else`子句的返回值类型一致：
```
let mut i = 10
let r1 =//提供一个接受while返回值的变量
    while i > 0 {
      i = i - 1
      if i % 2 == 0 { break 5 } // 跳出循环并返回 5
    } else {
      7
    }
  println(r1) //output: 5
```

##### 3.for循环
类似于c++的for形式，i的作用域在整个循环中，且不可改变
```
for i = 0; i < 5; i = i + 1 {
  println(i)
}


```
for同样支持`continue`、`break`和`else`子句。和`while`循环一样，`for` 循环同样 支持使用`break`和`else`子句使`for`语句返回一个值。
	使用continue会跳过本次for循环的剩余部分

for..in：循环语法遍历各种数据结构和序列（会被翻译为迭代器）
```
for k, v in { "x": 1, "y": 2, "z": 3 } {
  println("\{k} => \{v}")
}

//output
//x => 1
//y => 2
//z => 3
```

##### 4.函数式循环：
以函数式风格编写循环，使用loop定义
循环体是一系列子句，每个子句由模式和表达式组成。 与输入匹配的模式会被执行，并且循环将返回表达式的值。如果没有匹配的模式，循环将抛出异常。 可以使用 `continue` 关键字和参数开始下一次循环迭代，使用 `break` 关键字和参数来从循环中返回一个值。 如果值是循环体中的最后一个表达式，则可以省略 `break` 关键字。
```
fn sum(xs: @immut/list.T[Int]) -> Int {
  loop xs, 0 {
    Nil, acc => break acc // break 可以省略
    Cons(x, rest), acc => continue rest, x + acc
  }
}
```

##### 5.卫语句
卫语句用于检查指定的不变量。如果不变量的条件满足，程序继续执行后续的语句并返回。 如果条件不满足（即为假），则执行 `else` 块中的代码并返回它的求值结果（后续的语句会被跳过）。
```
guard index >= 0 && index < len else {
  abort("Index out of range")
}
```